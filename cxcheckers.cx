package board

type Point struct {
	x i32
	y i32
}

func double (n i32) (res i32) {
	res = i32.add(n, n)
}

var board [8][8]i32

func PopulateNewBoard() {

	board[0][0] = 0
	board[0][1] = 2
	board[0][2] = 0
	board[0][3] = 2
	board[0][4] = 0
	board[0][5] = 2
	board[0][6] = 0
	board[0][7] = 2

	board[1][0] = 2
	board[1][1] = 0
	board[1][2] = 2
	board[1][3] = 0
	board[1][4] = 2
	board[1][5] = 0
	board[1][6] = 2
	board[1][7] = 0

	board[2][0] = 0
	board[2][1] = 2
	board[2][2] = 0
	board[2][3] = 2
	board[2][4] = 0
	board[2][5] = 2
	board[2][6] = 0
	board[2][7] = 2

	board[3][0] = 3
	board[3][1] = 0
	board[3][2] = 3
	board[3][3] = 0
	board[3][4] = 3
	board[3][5] = 0
	board[3][6] = 3
	board[3][7] = 0

	board[4][0] = 0
	board[4][1] = 3
	board[4][2] = 0
	board[4][3] = 3
	board[4][4] = 0
	board[4][5] = 3
	board[4][6] = 0
	board[4][7] = 3

	board[5][0] = 1
	board[5][1] = 0
	board[5][2] = 1
	board[5][3] = 0
	board[5][4] = 1
	board[5][5] = 0
	board[5][6] = 1
	board[5][7] = 0

	board[6][0] = 0
	board[6][1] = 1
	board[6][2] = 0
	board[6][3] = 1
	board[6][4] = 0
	board[6][5] = 1
	board[6][6] = 0
	board[6][7] = 1

	board[7][0] = 1
	board[7][1] = 0
	board[7][2] = 1
	board[7][3] = 0
	board[7][4] = 1
	board[7][5] = 0
	board[7][6] = 1
	board[7][7] = 0

//	board = [8][8]i32{
//		{0, 2, 0, 2, 0, 2, 0, 2},
//		{2, 0, 2, 0, 2, 0, 2, 0},
//		{0, 2, 0, 2, 0, 2, 0, 2},
//		{3, 0, 3, 0, 3, 0, 3, 0},
//		{0, 3, 0, 3, 0, 3, 0, 3},
//		{1, 0, 1, 0, 1, 0, 1, 0},
//		{0, 1, 0, 1, 0, 1, 0, 1},
//		{1, 0, 1, 0, 1, 0, 1, 0}}

}


func PrintBoard() {
	str.print(BoardAsString())
}

func BoardAsString() (bs str) {
	//pieces := map[i32]str{
	//	0: "=",
	//	1: "X",
	//	2: "O",
	//	3: " ",
	//	7: "%",
	//	8: "0",
	//}

	var row [8]str
	row[0] = "8"
	row[1] = "7"
	row[2] = "6"
	row[3] = "5"
	row[4] = "4"
	row[5] = "3"
	row[6] = "2"
	row[7] = "1"

	var pieces [9]str
	pieces[0] = "="
	pieces[1] = "X"
	pieces[2] = "O"
	pieces[3] = " "
	pieces[4] = " "
	pieces[5] = " "
	pieces[6] = " "
	pieces[7] = "%"
	pieces[8] = "0"
	
	bs = ""
	var i i32
	var j i32

	for i := 0; i < 8; i++ {
		bs = bs + row[i]
		for j := 0; j < 8; j++ {
			bs = bs + " | " + pieces[board[1][2]]
			//bs = bs + " | " + pieces[board[i][j]]
			//i32.print(i)
			//i32.print(j)
			//i32.print(board[i][j])
		}
		bs = bs + " |\n"

	}

	bs = bs + "    A   B   C   D   E   F   G   H "

	//return boardString
}

package checkers
import "board"

func triple (n i32) (res i32) {
	res = i32.mul(n, 3)
}

var playing bool

func PlayerTurn(player i32, capOnly bool, lastPos [2]i32) {
	board.PrintBoard()
	playing = false
}

package main
import "board"
import "checkers"

func main () {
	
	var lp[2]i32

        str.print("Welcome to CX Checkers!\n")
	str.print("You play by specifying which piece to move, and the position to move it too")
	str.print("You can string captures, the game will let you know if you must take the next capture")
	str.print("You can also 'quit' at anytime")
	str.print("\nHave fun!\n")

	board.PopulateNewBoard()
	checkers.playing = true

	lp[0] = 0
	lp[1] = 0

	//checkers.PlayerTurn(1, false, lp)

	//for true {
		
	//	checkers.PlayerTurn(1, false, lp)
	//	if !checkers.playing {
	//		break
	//	}
	//	checkers.PlayerTurn(2, false, lp)
	//}

	play_loop:

	checkers.PlayerTurn(1, false, lp)
	if !checkers.playing {
		goto end_play
	}
	checkers.PlayerTurn(2, false, lp)
	goto play_loop

	end_play:

	str.print("\nGame Over!\n")

	//var p Point
	//p = board.Point{x: 10, y: 20}

	//i32.print(p.x)
	//i32.print(p.y)
	          
	//var double i32
	//var triple i32
	
	//double = board.double(10)
	//triple = checkers.triple(10)

	//i32.print(double)
	//i32.print(triple)
}

