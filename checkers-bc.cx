package bc

var game_id[]str
var game_steps[][5]i32
var lastgame i32

func newGame(id str) (pos i32){
	var jp i32
	jp = joinGame(id)
	if jp == -1 {
		game_id = append(game_id, id)
		lastgame = len(game_id)-1
		pos = lastgame
	} else {
		pos = -1
	}
	
}

func joinGame(id str) (pos i32){
	pos = -1
	for x := 0; x <= lastgame; x++ {
		if game_id[x] == id {
			pos = x
			return
		}
	}
}

// step[0] => player id (1 or 2)
// step[1] and step[2] => source x and y
// step[3] and step[4] => destination x and y

func saveStep(game str, step [5]i32) {

	
}

func viewBoard(board [8][8]i32) (v str) {

	var row [8]str
	row = [8]str {"8","7","6","5","4","3","2","1"}
	
	v = ""

	for i := 0; i < 8; i++ {
		v = v + row[i]
		for j := 0; j < 8; j++ {

			v = v + " | "
			if board[i][j] == 0 {
				v = v + "="
			} else if board[i][j] == 1 {
				v = v + "X"
			} else if board[i][j] == 2 {
				v = v + "O"
			} else if board[i][j] == 3 {
				v = v + " "
			} else if board[i][j] == 7 {
				v = v + "%"
			} else if board[i][j] == 8 {
				v = v + "0"
			}

		}
		v = v + " |\n"

	}

	v = v + "    A   B   C   D   E   F   G   H "

}

func OnBoard(vert i32, hoz i32) (ob bool) {
	if vert > 7 || vert < 0 || hoz > 7 || hoz < 0 {
		ob = false
		return
	}
	ob = true
}

func EnemyOnBoard(player i32, board [8][8]i32) (e bool) {
	var enemy i32
	enemy = 2
	if player == 2 {
		enemy = 1
	}

	for i := 0; i < 8; i++ {
		for j := 0; j < 8; j++ {
			if board[i][j] == enemy || board[i][j] == enemy+6 {
				e = true
				return
			}
		}
	}
	e = false
}

func GetPossiblePos(player i32) (vert [2]i32) {
	vert[0] = -1
	if player == 2 {
		vert[0] = 1
	}
	vert[1] = -2
	if player == 2 {
		vert[1] = 2
	}
}


func ValidMove(player i32, mov1 [2]i32, mov2 [2]i32, capOnly bool, noLog bool, board [8][8]i32) (valid bool) {
	valid = false

	if OnBoard(mov1[0], mov1[1]) == false || OnBoard(mov2[0], mov2[1]) == false {
		return
	}

	var enemy i32
	enemy = 2
	if player == 2 {
		enemy = 1
	}

	//printf("starting board: %d, %d, %d\n", mov1[0], mov1[1], board[mov1[0]][mov1[1]])
	if board[mov1[0]][mov1[1]] != player && board[mov1[0]][mov1[1]] != player+6 {
		if !noLog {
			printf("Starting posistion invalid %d\n", board[mov1[0]][mov1[1]])
		}
		return
	}

	//printf("board 2: %d\n", board[mov2[0]][mov2[1]])
	if board[mov2[0]][mov2[1]] != 3 {
		if !noLog {
			printf("Moving posistion invalid %d\n", board[mov2[0]][mov2[1]])
		}
		return
	}
	
	if CaptureChecks(player, mov1, mov2, capOnly, enemy, false, board) == true{
		//printf("CaptureChecks\n")
		valid = true
	} else if board[mov1[0]][mov1[1]] == player+6 && CaptureChecks(player, mov1, mov2, capOnly, enemy, true, board) == true{
		valid = true
	}
	
}


func CaptureChecks(player i32, mov1 [2]i32, mov2 [2]i32, capOnly bool, enemy i32, kingFlip bool, board [8][8]i32) (cc bool) {
	cc = false

	var hoz i32
	hoz = mov1[1] - mov2[1]
	var vert [2]i32

	vert = GetPossiblePos(player)
	if kingFlip {
		vert[0] = -vert[0]
		vert[1] = -vert[1]
	}

	var abshoz i32
	abshoz = 0
	if hoz == 1 || hoz == -1 {
		abshoz = 1
	}


	if mov2[0]-mov1[0] == vert[0] && abshoz == 1 && !capOnly {

		//printf("true: %d\n", abshoz)
		cc = true
		return
	}

	if mov2[0]-mov1[0] == vert[1] {
		if hoz == -2 && OnBoard(mov1[0]+vert[0], mov1[1]+1) {
			if board[mov1[0]+vert][mov1[1]+1] == enemy || board[mov1[0]+vert[0]][mov1[1]+1] == enemy+6 {
				cc = true
				return
			}
		} else if hoz == 2 && OnBoard(mov1[0]+vert[0], mov1[1]-1) {
			if board[mov1[0]+vert[0]][mov1[1]-1] == enemy || board[mov1[0]+vert[0]][mov1[1]-1] == enemy+6 {
				cc = true
				return
			}
		}
	}
}


func ValidMoves(player i32, board [8][8]i32) (valids [][2][2]i32) {
	var vert [2]i32
	vert = GetPossiblePos(player)

	for i := 0; i < 8; i++ {
		for j := 0; j < 8; j++ {
			

			if board[i][j] != player && board[i][j] != player+6 {
			//if board[i][j] != player {
				//continue	-> BUG: continue exit to root level for loop
			} else {
				var checkMoves [4][2]i32
				checkMoves[0][0] = i + vert[0]
				checkMoves[0][1] = j + 1
				checkMoves[1][0] = i + vert[0]
				checkMoves[1][1] = j - 1
				checkMoves[2][0] = i + vert[1]
				checkMoves[2][1] = j + 2
				checkMoves[3][0] = i + vert[1]
				checkMoves[3][1] = j - 2

				var currentPos [2]i32
				currentPos = [2]i32{i, j}

				for i := 0; i < 4; i++ {
					//printf("currentPos: %d, %d. move: %d, %d.\n", currentPos[0], currentPos[1], checkMoves[i][0], checkMoves[i][1])
					if ValidMove(player, currentPos, checkMoves[i], false, true, board) {
						//printf("valids1\n")					
						valids = append(valids, [2][2]i32{currentPos, checkMoves[i]})
					}
				}

				if board[i][j] == player+6 {
					var kingMoves [4][2]i32
					checkMoves[0][0] = i - vert[0]
					checkMoves[0][1] = j + 1
					checkMoves[1][0] = i - vert[0]
					checkMoves[1][1] = j - 1
					checkMoves[2][0] = i - vert[1]
					checkMoves[2][1] = j + 2
					checkMoves[3][0] = i - vert[1]
					checkMoves[3][1] = j - 2
					for i := 0; i < 4; i++ {
						if ValidMove(player, currentPos, kingMoves[i], false, true, board) {
							valids = append(valids, [2][2]i32{currentPos, checkMoves[i]})
						}
					}
				}
			}
		}
	}
}


func NewBoard() (board [8][8]i32) {
	var tmprow [8]i32

	tmprow = [8]i32 {0,2,0,2,0,2,0,2}
	board[0] = tmprow

	tmprow = [8]i32 {2,0,2,0,2,0,2,0}
	board[1] = tmprow

	tmprow = [8]i32 {0,2,0,2,0,2,0,2}
	board[2] = tmprow

	tmprow = [8]i32 {3,0,3,0,3,0,3,0}
	board[3] = tmprow

	tmprow = [8]i32 {0,3,0,3,0,3,0,3}
	board[4] = tmprow

	tmprow = [8]i32 {1,0,1,0,1,0,1,0}
	board[5] = tmprow
	
	tmprow = [8]i32 {0,1,0,1,0,1,0,0}
	board[6] = tmprow

	tmprow = [8]i32 {1,0,1,0,1,0,1,0}
	board[7] = tmprow
}


func PlayerTurn(game str, player i32, tmov1 [2]str, tmov2 [2]str, board [8][8]i32) (msg str){
	var playing bool
	var playerOneStuck bool
	var playerTwoStuck bool

	playerOneStuck = false
	playerTwoStuck = false
	playing = true

	var lp [2]i32
	lp = [2]i32 {0,0}
}


package main
import "bc"

func main() {

	bc.lastgame=-1

	//tx

	/*
	//test1
	var new1 i32
	new1 = bc.newGame("g7890")
	if new1 == -1 {
		printf("test1: error new game g7890, aleady exist!\n")
	} else {
		printf("test1: New game g7890 created, id: %d\n", new1)
	}

	//test2
	var new2 i32
	new2 = bc.newGame("g7890")
	if new2 == -1 {
		printf("test2: error new game g7890, aleady exist!\n")
	} else {
		printf("test2: New game g7890 created, id: %d\n", new2)
	}

	//test3
	new2 = bc.newGame("g7891")
	if new2 == -1 {
		printf("test3: error new game g7891, aleady exist!\n")
	} else {
		printf("test3: New game g7891 created, id: %d\n", new2)
	}

	//test4
	var join1 i32
	join1 = bc.joinGame("g7891")
	if join1 == -1 {
		printf("test4: error join game g7891, not exist!\n")
	} else {
		printf("test4: Join game g7891 success, id: %d\n", join1)
	}

	//test5
	var join2 i32
	join2 = bc.joinGame("g7892")
	if join2 == -1 {
		printf("test5: error join game g7892, not exist!\n")
	} else {
		printf("test5: Join game g7892 success, id: %d\n", join2)
	}
	*/



	var board [8][8]i32
	var gameID str
	var game1 i32
	var ng i32
	var tmov1 [2]str
	var tmov2 [2]str
	var msg str

	board = bc.NewBoard()



	// ==== step0
	
	str.print(bc.viewBoard(board))

	gameID = "G-001"
	ng = bc.newGame(gameID)



	// ==== step1

	gameID = "G-001"
	game1 = bc.joinGame(gameID)
	
	tmov1[0] = "i"
	tmov1[1] = "3"
	tmov2[0] = "b"
	tmov2[1] = "4"

	str.print(bc.PlayerTurn(gameID, 1, tmov1, tmov2, board))

	str.print(bc.viewBoard(board))



	// ==== step2

	gameID = "G-001"
	game1 = bc.joinGame(gameID)
	
	tmov1[0] = "d"
	tmov1[1] = "6"
	tmov2[0] = "c"
	tmov2[1] = "5"

	str.print(bc.PlayerTurn(gameID, 2, tmov1, tmov2, board))

	str.print(bc.viewBoard(board))




	
	





}
